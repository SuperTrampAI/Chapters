python相对java，c代码量少，运行效率底。

每门语音都有自己的特性，c语音适合写操作系统，iphone app使用wift/Objective-C ，andorid app使用java。

c适合使用那些追求运行速度，充分发挥硬件性能的程序。python适合编写应该程序。

python包含内置的库，称为：内置电池。还有大量的第三方的库。

python适合做哪些场景下的应该：首先是网络应用：网站，后台服务等等；其次是日常需要的小工具等等；另外还可以把其他语言开发的程序包装起来，方便使用。

1.python相对效率低，在如果十分在意效率，直接使用c，python是解释型的语音，这个无法改变。而对于应用层的用户来说，在秒级单位的效率低，是可以接受的，而如果上升到分钟级别
，才会应该去考虑效率，去做相应的优化
2.代码不能加密。解释型的语言必须把源代码交出去，而编译型的语音不用，只需要把机器码给出去。不把自己的源代码交出去的目的，就是靠编写的软件代码卖给别人挣钱（买卖
代码具有巨大的商业价值，这种事情是存在的，比如我现在待的这家公司：翰声，整个公司的基础就是建立在一个人写的代码上面的，包括业务等，构建了一个平台。），
而这种商业模式的弊端在哪里？现状是现在这种商业模式时越来越少的，现在的商业模式大多是靠网站和移动应用卖服务的模式越来越多，服务很重要，软件不重要，或者是
排到了相对后面的位置。

使用len计算字符长度，使用len(''.encode('utf-8'))计算字节长度。

使用%?在字符串中，实现占位符：d整数 f浮点数 s字符串 x十六进制 ，而如果无法确定是什么类型，则使用%s，该占位符会自动把任何数据类型转换成字符串
还有一种格式化字符串的方式：format() '{}'.format('')


--------------
list:有序集合，语法：[]定义，中间使用逗号隔开。最好一个元素的索引是len（list）-1
可以使用负数下标去倒数的元素，-1是倒数第一个值
查找和插入的时间随着元素的增加而增加，占用空间少，浪费内存很少（利用时间换空间）
list添加元素：
    list.appent('') 在最后添加元素。
    list.insert(1,'name') 在指定位置添加元素
    list中可以添加另外一个list

list删除元素：
    list.pop() 删除最后一个元素，并弹出该元素的值，该方法的参数，为空则删除最后一个，不为空则删除指定下标的值

修改：list[index]=''


-------------------------------

元组：tuple，一旦初始化完成，就不能修改，语法：()，多个元素之间使用逗号隔开。
由于tuple的不可变，所以代码更安全，能用tuple替代就尽量用tuple。
定义元组的语法在于使用逗号的使用，如果只是在括号中包含一个元素，而没有括号，则不是一个元组。


-------------------

dict ：字典，在其他语言中也成为map：key-value存储，具有极快的查找速度;需要占用大量的内存（利用空间换时间。）
多次插入同一个键值，后面插入的会把前面的覆盖掉。
语法：names={'key':value,}
后续插入：names['key']=value
判断键是否存在：“key” in keys
keys.get(‘key’,-1) 该方法如果没有查找到，不会抛出异常，会返回None，或者指定的值:-1
删除值：keys.pop(key)

--------------------
set 其中存放的值，不重复，无序
s=set([1,2,3,4])
添加：s.add(5)
删除：s.remove(key)
集合可以做交集并集等操作。 & 并集 | 交集
对于不可变类型的对象，就算是调用了类似replace方法，也不会改变其字符串对象的值，只不过是创建了一个新的对象，然后另一个变量指向了这个新的对象值

----------------

if x 判断是可以又默认值的：只要x是非零数值，非空字符串，非空list等，就判断为True，否则为False

---------------

for name in names  for in 循环，把list或tuple中的每个元素迭代出来。
while循环：只要条件满足，就不断循环。在while循环中，使用break退出循环；使用continue跳过当前循环。


    对于不可变对象的优点：在多任务环境下，读取不可变对象无需加锁。
-----------------
函数
    python内置函数：abs：绝对值；max：返回最大的一个值，可以接受多个值；int('') 吧其他类型转换为整数型；类似的还有：float;sr;bool;
    把一个函数对象赋值给一个变量时，无序括号，直接赋值。相当于把这个函数名取了一个变量，可以通过这个变量直接使用该函数
    isinstance() 数据类型检查 例子：if not isinstance(x,(int,float))  ：x不是int和float 则进入该判断


    自定义函数：使用def语句，在python中，如果没有return返回语句，也会返回None，return None简写为return.
        如果把函数method()定义在MyMethod.py中，导包：from py import method来导入该函数。
        python中空函数：在def定义的方法中，什么也没有，只有一个pass语言，pass可以用来作为占位符，可以让代码可以运行起来。
        python函数中可以返回多个值，直接在return中返回多个值，使用逗号分隔，在调用方法时，使用多个参数接受，使用逗号分隔。实际上，在方法中返回的使用逗号分隔的就是一个元组tuple
            返回一个tuple可以升华括号，直接使用逗号分隔。

        对于函数的参数：
            1.位置参数：函数中，可以传入多个参数，在传入时，无需指定参数名，按照指定顺序传入即可，如果一个方法定义了n个参数，在调用时，必须要传入n个参数
            2.默认参数：依据1，如果没有要求传入n个参数，则需要在定义方函数时，设置函数的默认值def method(a,b=2) 则在调用方法是，无需传入两个参数
                需要注意的：1.必选参数在前，就是没有默认值的在前面，设置了默认参数的在后。对于非必要的参数，可以设置一个默认值。
            3.在调用函数时，按照函数定义的顺序调用，无需写参数名，在不按照函数定义的参谋顺序调用时，可以写上参数名，而无需依据参数顺序。
            4.在调用可变参数时，可以传入一个list或者tuple，或者是在定义函数是，          语法：在参数名前面加入一个*符号；
                在调用一个可变参数函数时，把一个已存的list类的集合传入进函数，可以在集合参数名前加入*。
            5.关键字参数：关键字参数在函数内部自动组装为一个dict字典，是一个键值对。和可变参数一样，可以先组装出一个dict，在调用方法时，在调用方法时，
                在dict变量名前加入**传入进函数。                       语法：在定义方法时，在参数前面加上两个星号  def person(name,age,**kw),当在调用方法，传入关键字参数时，语法为字典形式：{'key':'value'} 在函数内部，自动组装成dict字典。
                实参是对形参的拷贝，对实参的修改，不会影响到函数外的形参。
                关键字参数的语法：在*后面的为关键字参数：def person(name,age,*,city,job): *号后面的为关键字参数，如果函数中已经有了一个可变参数，则后面跟着的关键字参数不再需要*型号分隔符。
                关键字参数必须在调用参数时，必须传入参数名，否则将报错（）星号前面的为顺序参数，星号后面的为关键字参数，如果有一个使用星号定义的参数为可变参数，有这个可变参数则无需再使用*星号来定义关键字参数，关键字参数可以设置默认值，设置了默认值的关键字参数，在调用时，非必要赋值参数。
            6.如果要限制关键字参数的名字，可以使用命名关键字参数。在*星号后面定义参数。def person(age,name,*,city,address) city和address为命名关键字参数，
            7.各类参数的组合使用：首先所以类型的参数都可以组合使用，但是，顺序为：必选参数，默认参数，可变参数，命名关键字参数，关键字参数
                语法：def f1(a,b,c=1,*args,**kw)
                        a和b必须传，c在传入时，必须指定参数名，可变参数在转时，直接传值，使用逗号分隔，在函数内部，默认转成tuple元组；关键字参数在传值时，使用赋值方式传值：x=value，字典的格式
                      def f2(a,b,c=1,*,d,**kw)

                    调用示例：
                        f1(1,2)
                        f1(1,2,c=3)
                        f1(1,2,3,'a','b') a和b为*args可变参数的值
                        f1(1,2,3,'','',x=99)
                        f2(1,2,d=99,ext=None) d为可变参数，而c有默认值，可以无需传入

                        args=(1,2,3,4)
                        kw=["":"","":""]
                        f1(*args,**kw)

                        args=(1,2,3)
                        kw=["":"","":""]
                        f2(*args,**kw)

                        所以对于任意函数，都可以通过类似func(*args,**kw)来调用该函数。无论ta的参数是如何定义的。

                        但是基于可理解性的角度，不要同时使用太多的组合，使得可理解性很差。

                        递归函数：在函数内部，调用自身本身，这个函数就是递归函数，递归函数的逻辑清晰

切片：
    L=list，tuple,字符串也可以进行切片操作
    语法：L[0:3] 从索引0开始，到索引3位置，不包括索引3.默认开始下标为0.
            支持从-1开始取到倒数第一个元素，-2是开始下标，-1是结束下标
    示例：L[:10] 前十个数，开始下标默认值为0，可以省略
          L[-10:] 后十个元素
          L[10:20] 前11-20个元素，下标从0开始，所以下标10位第十一个元素
          L[:10:2] 前十个元素，每两个取得一个，步进的方式
          L[::5] 在所有元素中，步进每五个取得一个
          L[:] 复制该list

迭代：
    迭代dict字典对象：
        for key in dict dict为字典，该语法为迭代key值
        for value in dict.values() dict为字典，该语法为取得字典中的值，进行迭代。
        for k,v in dict.items() dict为字典，该无法为同时迭代key和value
    迭代str对象：for ch in string:

    for .. in .. 该语法在python中迭代抽象层度相对高，只要是一个可迭代对象，就可以通过该方式进行对象的迭代
    通过方法来判断是否可以是可迭代对象： from collections import Iterable isinstance(需要判断的对象,Iterable) 该方法如果足够抽象，可能的定义就是：参数1为被判断的对象，参数2为标准，参数1是否是参数2的继承类

    通过enumerate函数把list转换成[下标-元素]对应的格式，语法如下：
        for i,value in enumerate(['','','']) : i从0开始 value为list中的元素

列表生成式：
    即：list comprehensions
    示例：list(range(1,11))
          [x * x for x in range(1,11)] 把for中的x，在for外进行运算，换一种说法就是把for循环生成的值，放在前面，进行一个运算；可以在for循环外加入if判断
          [m+n for m in 'ABC' for n in "DEF"] 可以加入多重循环，在前面进行一个操作
          在生成式中使用的多个变量的方式，除了从多个for从得到值以外，还可以通过循环dict字典的key和value中得到，语法如下：
            [k,w for k,w in dict.itmes()]
          三层或以上的的生成式就很少用到了。
          同时还可以在前面调用变量可以调用的方法，比如如果循环的是一个字符串，可以调用字符串对应的方法，比如str.lower()
            [s.lower() for s in ['','','','']]

生成器：生成器，是循环过程中，不断推算出后续的元素，通过算法来进行一个迭代，在过程中保存的也是算法，节省了大量的空间
    语法：g=(x for x in range(10)) 可列表生成式的区别是最外围使用的括号不同，生成器使用的是圆括号。
    迭代生成器的方式：通过调用generator对象的next()方法，迭代到最好一个元素，则抛出StopIteration.
    手动调用next方法的使用场景在于实现自定义的生成器，而如果非自定义的，则可以使用for循环来迭代generator对象
        for n in g:
    对于自定义的函数，只需要在函数定义中包含yield关键字，该函数就是一个generator。
    generator的执行过程：调用该类函数时，每次调用next方法是执行，遇到yield语句返回。再次调用next方法执行时，从上次返回的yield语句出继续执行。
    如果是根据某种算法来定义的生成器，则需要设置该算法的跳出机制，在什么情况下，停止该生成器。

迭代器：可用于for循环的为可迭代对象：Iterable
    生成器可以作用域for循环，还坑被next方法不断调用并返回下一个值。可以并next函数调用的对象成为迭代器：Iterator
    list,dict,str都是iterable，不是iterator，无法调用next函数，同时可以转iterable为iterator：通过iter函数把list等iterable转为iterator

函数式编程：
    函数（方法）把大段的代码拆成函数，通过函数来一层层的调用，把整体复杂的，分解为局部简单的任务，这种分解成为面向过程的程序设计。
    函数式编程：纯粹的函数式编程语言没有变量，特点：可以把函数本身传给另一个函数，还允许返回一个函数。

 高阶函数：Higher order function
    变量可以指向函数 比如abs()----abs 可以把不带括号的函数赋值给变量，然后通过该变量还调用函数。
    对于python中内置的函数，可以通过赋值把该函数名覆盖掉，而在覆盖以后，无法调用函数，比如abs=10后，无法调用求绝对值的函数abs，覆盖以后需要重启python交互环境，即退出以后在进入
    一个函数可以接受另一个函数作为参数，这种函数就称为高阶函数，同时python为动态类型，所以从函数的参数名上来看，无根本性差别。
    map():接受两个参数：参数1接受一个函数，参数2接受一个Iterable。map将传入的函数依次作用到iterable的每个元素上，并把结果返回
        map(func,[1,2,3,4,5,6]) 自定义func方法，或者可以使用内置的函数，来对list中的值进行一个操作
    reduce()：把一个函数作用在一个序列上，这个函数必须接受两个参数，把结果继续和序列的下一个元素做累计计算。
    filter():用于过滤序列 接受一个函数和一个序列，吧传入的函数一次作用于每个元素，然后更具返回值是true还是false决定保留还是丢弃该元素，根据函数的返回值来判断是否把一个值添加进待返回的list中
    sorted():可以通过sorted对list进行排序，同时sorted也是一个高阶函数，在第一个参数list后，还可以接受一个key函数来实现自定义的排序。
        key将制定的函数作用域list的每一个元素上，并根据key函数返回的结果进行排序。sorted函数的高阶用法关键在于先把根据key函数以后的list返回后，在排序。
        示例：sorted([1,2,3,4,5,6],key=abs)
        对于字符串的比较，是按照ascii比较的，Z在a前面 可以使用把如下方法忽略这一大小写的排序：sorted(['','','',key=str.lower)
        进行反向排序只需要传入第三个参数：reverse=True
    返回函数：把函数return返回：在方法中定义一个方法，然后在外层方法返回该方法。在使用时，调用外层方法，得到一个返回值，然后在调用返回值（函数）

匿名函数：
    关键字lambda代表匿名函数：lambda x:x*x  局限：智能有一个表达式，不用谢return，返回值就是该表达式的结果。冒号前面的为函数参数。
    没有函数名，不用考虑函数名冲突，以及可以把匿名函数赋值给一个变量，再利用变量来调用该函数。
    也可以在函数中定义匿名函数然后return。


装饰器：在代码运行期间动态增加功能的方式，称之为“装饰器”Decorator
    本质上，decorator就是一个返回函数的高阶函数
    @functools.wraps(func)
    def log(func):
        def wrapper(*args, **kw):
            print('call %s():' % func.__name__)
            return func(*args, **kw)
        return wrapper

    @log
    def now():
        print('2015-3-25')

    在调用now方法是，会先打印log方法中的输出语句，然后打印now中的输出语句
    把log放到now上，相当于把now函数传入到log方法中，从而就是打印log中的语句，然后打印now方法中的语句

偏函数：Partial function
    内置函数int()可以传入不同的参数，来进行不同进制的转换，语法：int('1234',base=8\16) base默认值为10
    而对于这种需要在原有的函数中，设置和原有默认值不同的默认值，除了自己定义的方法外，还可以勇士functools中的partial函数来定义偏函数,语法如下：
        int2=functools.partial(int,base=2) 扩展原有方法，为原有方法中的参数，设置默认值，来简化函数的调用。




惰性序列：Iterator


